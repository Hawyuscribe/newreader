from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from django.contrib import messages
from django.contrib.auth import login, logout, authenticate
from django.db.models import Count, Case, When, IntegerField, F, Q
from django.utils import timezone
from django.views.decorators.http import require_POST
from django.views.decorators.csrf import csrf_exempt
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm

from datetime import datetime, timedelta
import json
import re  # Added for regex operations

from .models import MCQ, Bookmark, Flashcard, Note, ReasoningSession
from .openai_integration import generate_explanation, improve_question, generate_new_options, verify_mcq_answer, answer_question_about_mcq, clinical_reasoning_coach

# Subspecialty definitions
SUBSPECIALTIES = [
    "Critical Care Neurology", "Dementia", "Epilepsy", "Headache", 
    "Movement Disorders", "Neuroanatomy", "Neurogenetics", "Neuroimmunology",
    "Neuro-infectious", "Neuro-oncology", "Neuro-otology", "Neuroophthalmology",
    "Neuropsychiatry", "Neurotoxicology", "Neuromuscular", "Pediatric Neurology",
    "Sleep Neurology", "Vascular Neurology/Stroke", "Other/Unclassified"
]

# Mapping between display names and database names
SUBSPECIALTY_MAPPING = {
    "Neuro-infectious": "Neuro-infectious",
    "Neuro-oncology": "Neuro-oncology", 
    "Neuro-otology": "Neuro-otology",
    "Vascular Neurology/Stroke": "Vascular Neurology/Stroke",
    "Other/Unclassified": "Other/Unclassified"
}

def index(request):
    return redirect('dashboard')

def login_view(request):
    if request.method == 'POST':
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            username = form.cleaned_data.get('username')
            password = form.cleaned_data.get('password')
            user = authenticate(username=username, password=password)
            if user is not None:
                login(request, user)
                return redirect('dashboard')
        else:
            messages.error(request, "Invalid username or password.")
            
    form = AuthenticationForm()
    return render(request, 'mcq/login.html', {'form': form})

def register_view(request):
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            login(request, user)
            messages.success(request, "Registration successful!")
            return redirect('dashboard')
        else:
            messages.error(request, "Registration failed. Please correct the errors.")
    else:
        form = UserCreationForm()
    
    return render(request, 'mcq/register.html', {'form': form})

def logout_view(request):
    logout(request)
    return redirect('login')

@login_required
def dashboard(request):
    # Get counts of MCQs by subspecialty
    subspecialty_stats = []
    
    # Get all subspecialties with counts
    subspecialty_counts = MCQ.objects.values('subspecialty').annotate(total=Count('id'))
    
    # Convert to dictionary for easy lookup
    count_dict = {item['subspecialty']: item['total'] for item in subspecialty_counts}
    
    # Get flashcard counts for the current user
    flashcard_counts = Flashcard.objects.filter(user=request.user).values(
        'mcq__subspecialty').annotate(completed=Count('id'))
    
    # Convert to dictionary for easy lookup
    completed_dict = {item['mcq__subspecialty']: item['completed'] for item in flashcard_counts}
    
    # Build stats for each subspecialty
    for display_name in SUBSPECIALTIES:
        # Use the database name from mapping if it exists
        db_name = SUBSPECIALTY_MAPPING.get(display_name, display_name)
        
        total = count_dict.get(db_name, 0)
        completed = completed_dict.get(db_name, 0)
        
        # Ensure we don't divide by zero
        percentage = round((completed / total * 100), 1) if total > 0 else 0
        
        subspecialty_stats.append({
            'name': display_name,  # Display name for UI
            'db_name': db_name,    # DB name for queries
            'total': total,
            'completed': completed,
            'percentage': percentage
        })
    
    # Get flashcards due today and this week
    today = timezone.now()
    week_end = today + timedelta(days=7)
    
    flashcards_due = Flashcard.objects.filter(
        user=request.user, 
        next_review__lte=today
    ).count()
    
    flashcards_due_week = Flashcard.objects.filter(
        user=request.user, 
        next_review__lte=week_end
    ).count()
    
    # Get count of bookmarked MCQs
    bookmarked_count = Bookmark.objects.filter(user=request.user).count()
    
    # Get the flashcards due today and this week with their MCQ details for review
    flashcards_due_today = Flashcard.objects.filter(
        user=request.user, 
        next_review__lte=today
    ).select_related('mcq').order_by('next_review')
    
    flashcards_due_this_week = Flashcard.objects.filter(
        user=request.user, 
        next_review__lte=week_end,
        next_review__gt=today
    ).select_related('mcq').order_by('next_review')
    
    # Get bookmarked MCQs
    bookmarked_mcqs = Bookmark.objects.filter(
        user=request.user
    ).select_related('mcq').order_by('mcq__id')
    
    context = {
        'subspecialty_stats': subspecialty_stats,
        'flashcards_due': flashcards_due,
        'flashcards_due_week': flashcards_due_week,
        'bookmarked_count': bookmarked_count,
        'flashcards_due_today': flashcards_due_today,
        'flashcards_due_this_week': flashcards_due_this_week,
        'bookmarked_mcqs': bookmarked_mcqs
    }
    
    return render(request, 'mcq/dashboard.html', context)

@login_required
def search(request):
    query = request.GET.get('query', '')
    
    if not query:
        return render(request, 'mcq/search_results.html', {'results': [], 'query': ''})
    
    # Search through database
    results = MCQ.objects.filter(
        Q(question_text__icontains=query) | 
        Q(options__icontains=query)
    ).order_by('-id')[:100]
    
    return render(request, 'mcq/search_results.html', {'results': results, 'query': query})

@login_required
def subspecialty_view(request, subspecialty):
    exam_type = request.GET.get('exam_type', 'All Types')
    start_year = request.GET.get('start_year', '2018')
    end_year = request.GET.get('end_year', '2024')
    
    # URL decode the subspecialty
    from urllib.parse import unquote
    subspecialty = unquote(subspecialty)
    
    # Convert display name to database name if needed
    db_subspecialty = SUBSPECIALTY_MAPPING.get(subspecialty, subspecialty)
    
    # Print debug info to help diagnose the issue
    print(f"Searching for subspecialty: '{db_subspecialty}'")
    print(f"Available subspecialties: {list(MCQ.objects.values_list('subspecialty', flat=True).distinct())}")
    
    # Base query
    mcqs = MCQ.objects.filter(subspecialty=db_subspecialty)
    
    # Apply filters
    if exam_type != 'All Types':
        mcqs = mcqs.filter(exam_type=exam_type)
    
    if start_year and end_year:
        try:
            mcqs = mcqs.filter(
                exam_year__gte=int(start_year),
                exam_year__lte=int(end_year)
            )
        except (ValueError, TypeError):
            # Handle case where exam_year might be null or not an integer
            pass
    
    # Order by ID
    mcqs = mcqs.order_by('id')
    
    # Count total MCQs in this subspecialty (without filters)
    total_mcqs = MCQ.objects.filter(subspecialty=db_subspecialty).count()
    
    context = {
        'subspecialty': subspecialty,
        'mcqs': mcqs,
        'exam_type': exam_type,
        'start_year': start_year,
        'end_year': end_year,
        'total_mcqs': total_mcqs
    }
    
    return render(request, 'mcq/subspecialty.html', context)

@login_required
def view_mcq(request, mcq_id):
    mcq = get_object_or_404(MCQ, id=mcq_id)
    
    # Check if this MCQ is a flashcard for the current user
    is_flashcard = Flashcard.objects.filter(mcq=mcq, user=request.user).exists()
    
    # Check if this MCQ is bookmarked by the current user
    is_bookmarked = Bookmark.objects.filter(mcq=mcq, user=request.user).exists()
    
    # Get user note for this MCQ
    try:
        user_note = Note.objects.get(mcq=mcq, user=request.user)
    except Note.DoesNotExist:
        user_note = None
    
    # Get next and previous MCQs in same subspecialty
    # Get all MCQs in the same subspecialty
    subspecialty_mcqs = MCQ.objects.filter(subspecialty=mcq.subspecialty).order_by('id')
    
    if not subspecialty_mcqs:
        next_mcq = None
        prev_mcq = None
    else:
        # Get the current MCQ's position
        current_mcq_ids = list(subspecialty_mcqs.values_list('id', flat=True))
        
        try:
            current_position = current_mcq_ids.index(mcq.id)
        except ValueError:
            # MCQ not found in list (shouldn't happen, but just in case)
            current_position = -1
        
        # Get next MCQ (with wrap-around)
        if current_position >= 0 and current_position < len(current_mcq_ids) - 1:
            next_mcq_id = current_mcq_ids[current_position + 1]
            next_mcq = MCQ.objects.get(id=next_mcq_id)
        elif current_position == len(current_mcq_ids) - 1:
            # Wrap to first
            next_mcq_id = current_mcq_ids[0]
            next_mcq = MCQ.objects.get(id=next_mcq_id)
        else:
            next_mcq = None
        
        # Get previous MCQ (with wrap-around)
        if current_position > 0:
            prev_mcq_id = current_mcq_ids[current_position - 1]
            prev_mcq = MCQ.objects.get(id=prev_mcq_id)
        elif current_position == 0:
            # Wrap to last
            prev_mcq_id = current_mcq_ids[-1]
            prev_mcq = MCQ.objects.get(id=prev_mcq_id)
        else:
            prev_mcq = None
            
    # Debug info
    print(f"Current MCQ: {mcq.id}, Next MCQ: {next_mcq.id if next_mcq else None}, Prev MCQ: {prev_mcq.id if prev_mcq else None}")
    
    # Process options if they're stored as JSON
    if mcq.options and isinstance(mcq.options, str):
        try:
            import json
            mcq.options = json.loads(mcq.options)
        except json.JSONDecodeError:
            # If options can't be parsed as JSON, keep as is
            pass
    
    # Check if explanation contains unwanted "Classification Reason" text and clear it if needed
    has_proper_explanation = False
    if mcq.explanation:
        # Check if it's a Classification Reason text (unwanted explanation)
        if "Classification Reason:" in mcq.explanation:
            # Consider this as not having a proper explanation
            clean_explanation = None
        else:
            # Keep the explanation if it's not a Classification Reason
            clean_explanation = mcq.explanation
            has_proper_explanation = True
    else:
        clean_explanation = None
    
    context = {
        'mcq': mcq,
        'user_note': user_note,
        'is_bookmarked': is_bookmarked,
        'is_flashcard': is_flashcard,
        'next_mcq': next_mcq,
        'prev_mcq': prev_mcq,
        'clean_explanation': clean_explanation,
        'has_proper_explanation': has_proper_explanation,
        'SUBSPECIALTIES': SUBSPECIALTIES  # Add the subspecialties list to the context
    }
    
    return render(request, 'mcq/mcq_detail.html', context)

@login_required
def check_answer(request, mcq_id):
    if request.method != 'POST':
        return JsonResponse({'error': 'Only POST requests allowed'})
    
    mcq = get_object_or_404(MCQ, id=mcq_id)
    selected_answer = request.POST.get('answer')
    is_correct = selected_answer == mcq.correct_answer
    
    return JsonResponse({
        'is_correct': is_correct,
        'correct_answer': mcq.correct_answer
    })

@login_required
def review_flashcards(request):
    # Get review type from query params
    review_type = request.GET.get('type', 'today')
    
    # Set up date filters based on type
    today = timezone.now()
    week_end = today + timedelta(days=7)
    
    # Base query
    flashcard_query = Flashcard.objects.filter(user=request.user).select_related('mcq')
    
    # Apply filters based on review type
    if review_type == 'today':
        due_flashcards = flashcard_query.filter(next_review__lte=today).order_by('next_review')
        if not due_flashcards:
            messages.info(request, "No flashcards due for review today!")
            return redirect('dashboard')
    elif review_type == 'week':
        due_flashcards = flashcard_query.filter(
            next_review__lte=week_end
        ).order_by('next_review')
        if not due_flashcards:
            messages.info(request, "No flashcards due for review this week!")
            return redirect('dashboard')
    else:
        # Default to today's flashcards
        due_flashcards = flashcard_query.filter(next_review__lte=today).order_by('next_review')
        if not due_flashcards:
            messages.info(request, "No flashcards due for review!")
            return redirect('dashboard')
    
    # Get the first due flashcard
    flashcard = due_flashcards.first()
    mcq = flashcard.mcq
    
    context = {
        'mcq': mcq,
        'flashcard': flashcard,
        'flashcards_count': due_flashcards.count(),
        'review_type': review_type
    }
    
    return render(request, 'mcq/flashcard_review.html', context)

@login_required
def review_bookmarked(request):
    # Check if we're filtering by subspecialty
    subspecialty = request.GET.get('subspecialty', None)
    
    # Base query
    bookmarked_query = Bookmark.objects.filter(user=request.user).select_related('mcq')
    
    # Apply subspecialty filter if provided
    if subspecialty:
        bookmarked_query = bookmarked_query.filter(mcq__subspecialty=subspecialty)
        
    # Get the filtered bookmarks
    bookmarked = bookmarked_query.order_by('id')
    
    if not bookmarked:
        if subspecialty:
            messages.info(request, f"You don't have any bookmarked MCQs in the {subspecialty} subspecialty!")
        else:
            messages.info(request, "You don't have any bookmarked MCQs!")
        return redirect('dashboard')
    
    # Get the first bookmarked MCQ
    bookmark = bookmarked.first()
    mcq = bookmark.mcq
    
    context = {
        'mcq': mcq,
        'bookmark': bookmark,
        'bookmarks_count': bookmarked.count(),
        'current_subspecialty': subspecialty
    }
    
    return render(request, 'mcq/bookmarked.html', context)

@login_required
@require_POST
def toggle_bookmark(request, mcq_id):
    mcq = get_object_or_404(MCQ, id=mcq_id)
    
    # Check if bookmark exists
    bookmark, created = Bookmark.objects.get_or_create(
        user=request.user,
        mcq=mcq
    )
    
    # If it wasn't created, then it existed before, so delete it
    if not created:
        bookmark.delete()
        messages.success(request, f"Bookmark removed for MCQ #{mcq_id}")
    else:
        messages.success(request, f"Bookmark added for MCQ #{mcq_id}")
    
    return redirect('view_mcq', mcq_id=mcq_id)

@login_required
@require_POST
def save_note(request, mcq_id):
    mcq = get_object_or_404(MCQ, id=mcq_id)
    note_text = request.POST.get('note', '')
    
    # Update or create a note
    note, created = Note.objects.update_or_create(
        user=request.user,
        mcq=mcq,
        defaults={'note_text': note_text}
    )
    
    messages.success(request, f"Note saved for MCQ #{mcq_id}")
    return redirect('view_mcq', mcq_id=mcq_id)

@login_required
@require_POST
def create_flashcard(request, mcq_id):
    mcq = get_object_or_404(MCQ, id=mcq_id)
    interval = int(request.POST.get('interval', '1'))
    
    # Calculate next review date
    next_review = timezone.now() + timedelta(days=interval)
    
    # Create/update flashcard
    flashcard, created = Flashcard.objects.update_or_create(
        user=request.user,
        mcq=mcq,
        defaults={
            'interval': interval,
            'next_review': next_review,
        }
    )
    
    messages.success(request, f"Flashcard {'created' if created else 'updated'} for MCQ #{mcq_id} with interval {interval} days")
    return redirect('view_mcq', mcq_id=mcq_id)

@login_required
@require_POST
def reclassify_mcq(request, mcq_id):
    mcq = get_object_or_404(MCQ, id=mcq_id)
    new_subspecialty = request.POST.get('subspecialty', '')
    
    if new_subspecialty:
        # Get database name if needed
        db_subspecialty = SUBSPECIALTY_MAPPING.get(new_subspecialty, new_subspecialty)
        
        # Update subspecialty
        mcq.subspecialty = db_subspecialty
        mcq.save()
        
        messages.success(request, f"MCQ #{mcq_id} reclassified to {new_subspecialty}")
    
    return redirect('view_mcq', mcq_id=mcq_id)

@login_required
@require_POST
def create_explanation(request, mcq_id):
    mcq = get_object_or_404(MCQ, id=mcq_id)
    
    # Check if regeneration request includes a reason
    reason = request.POST.get('reason', '')
    
    try:
        # Generate the explanation using OpenAI with a timeout
        from threading import Thread
        import time
        import uuid
        
        # Create a placeholder explanation with generating message
        placeholder_id = str(uuid.uuid4())
        progress_html = f"""
        <div class="explanation-wrapper" id="explanation-{placeholder_id}">
            <div class="alert alert-info">
                <h4><i class="bi bi-hourglass-split"></i> Generating explanation...</h4>
                <p>This may take up to 2 minutes to complete. The page will automatically update when ready.</p>
                <div class="progress mt-3">
                    <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" 
                        style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"></div>
                </div>
            </div>
            
            <script>
                // Poll for explanation completion
                (function checkExplanation() {{
                    fetch('/mcq/{mcq_id}/check_explanation/?id={placeholder_id}')
                    .then(response => response.json())
                    .then(data => {{
                        if (data.ready) {{
                            // Replace placeholder with real explanation
                            document.getElementById('explanation-{placeholder_id}').innerHTML = data.explanation;
                        }} else {{
                            // Check again after 5 seconds
                            setTimeout(checkExplanation, 5000);
                        }}
                    }})
                    .catch(error => {{
                        console.error('Error checking explanation:', error);
                        // Check again after 5 seconds even if there's an error
                        setTimeout(checkExplanation, 5000);
                    }});
                }})();
            </script>
        </div>
        """
        
        # Save the placeholder first
        mcq.explanation = progress_html
        mcq.save()
        
        # Start a background thread to generate the explanation
        def generate_explanation_thread():
            try:
                # Generate explanation
                explanation = generate_explanation(mcq, reason)
                
                # Process explanation using the existing processing code
                processed_explanation = _process_explanation(explanation)
                
                # Update the MCQ with the real explanation
                mcq.explanation = processed_explanation
                mcq.save()
            except Exception as e:
                # If there's an error, save it as the explanation
                error_html = f"""
                <div class="explanation-wrapper">
                    <div class="alert alert-danger">
                        <h4><i class="bi bi-exclamation-triangle"></i> Error generating explanation</h4>
                        <p>We encountered an error while generating the explanation: {str(e)}</p>
                        <p>Please try again later.</p>
                    </div>
                </div>
                """
                mcq.explanation = error_html
                mcq.save()
        
        # Return success immediately while generation continues in background
        Thread(target=generate_explanation_thread).start()
        
        # Return a success message immediately
        return JsonResponse({
            'success': True,
            'message': 'Explanation generation started. Please wait while we generate your explanation.',
            'placeholder_id': placeholder_id
        })
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'message': f'Error starting explanation generation: {str(e)}'
        })

@login_required
def check_explanation(request, mcq_id):
    mcq = get_object_or_404(MCQ, id=mcq_id)
    placeholder_id = request.GET.get('id', '')
    
    # Check if the explanation is still a placeholder
    if mcq.explanation and f'id="explanation-{placeholder_id}"' in mcq.explanation and 'Generating explanation' in mcq.explanation:
        return JsonResponse({
            'ready': False
        })
    
    # Explanation is ready
    return JsonResponse({
        'ready': True,
        'explanation': mcq.explanation
    })

# Process the explanation text into HTML
def _process_explanation(explanation):
    import re
    
    # Create TOC and wrapper for explanation
    toc_html = '<div class="toc-container mb-4"><h4><i class="bi bi-list-ul"></i> Contents</h4><ul class="toc-list">'
    explanation_html = '<div class="explanation-wrapper">'
    
    # Section Headers with icons (and add to TOC)
    sections = [
        (r'# Explanation of MCQ: (.*?)\n', 'explanation-title', '<i class="bi bi-book"></i> Explanation of MCQ: $1', 'Overview'),
        (r'# Question Recap\n', 'question-recap', '<i class="bi bi-chat-quote"></i> Question Recap', 'Question Recap'),
        (r'# Why the Correct Answer is Right\n', 'correct-answer', '<i class="bi bi-check-circle"></i> Why the Correct Answer is Right', 'Correct Answer'),
        (r'# Why Each Wrong Answer is Wrong\n', 'wrong-answers', '<i class="bi bi-x-circle"></i> Why Each Wrong Answer is Wrong', 'Wrong Answers'),
        (r'# Comparison Table of Options\n', 'comparison-table', '<i class="bi bi-table"></i> Comparison Table of Options', 'Comparison Table'),
        (r'# Clinical Pearls to Memorize\n', 'clinical-pearls', '<i class="bi bi-lightbulb"></i> Clinical Pearls to Memorize', 'Clinical Pearls'),
        (r'# Summary of Latest Guidelines\n', 'guidelines', '<i class="bi bi-journal-medical"></i> Summary of Latest Guidelines', 'Guidelines'),
        (r'# Historical Note\n', 'historical-note', '<i class="bi bi-clock-history"></i> Historical Note', 'Historical Note')
    ]
    
    for i, (pattern, section_id, header_html, toc_label) in enumerate(sections):
        toc_html += f'<li><a href="#section-{section_id}" class="toc-link">{toc_label}</a></li>'
        
        # For the first section (title)
        if i == 0:
            m = re.search(pattern, explanation)
            if m:
                title = m.group(1)
                explanation = re.sub(pattern, 
                    f'<section id="section-{section_id}" class="explanation-section">'
                    f'<div class="section-header" data-bs-toggle="collapse" data-bs-target="#content-{section_id}" aria-expanded="true">'
                    f'<h1>{header_html}</h1>'
                    f'<i class="toggle-icon bi bi-chevron-up"></i>'
                    f'</div>'
                    f'<div class="section-content collapse show" id="content-{section_id}">', explanation)
            else:
                # If no match, add the standard header
                explanation_html += (
                    f'<section id="section-{section_id}" class="explanation-section">'
                    f'<div class="section-header" data-bs-toggle="collapse" data-bs-target="#content-{section_id}" aria-expanded="true">'
                    f'<h1>{header_html.replace("$1", "")}</h1>'
                    f'<i class="toggle-icon bi bi-chevron-up"></i>'
                    f'</div>'
                    f'<div class="section-content collapse show" id="content-{section_id}">'
                )
                
        # For all other sections
        else:
            # Close previous section if needed
            if i > 0:
                explanation = re.sub(pattern, 
                    f'</div></section>'
                    f'<section id="section-{section_id}" class="explanation-section {section_id}">'
                    f'<div class="section-header" data-bs-toggle="collapse" data-bs-target="#content-{section_id}" aria-expanded="true">'
                    f'<h2>{header_html}</h2>'
                    f'<i class="toggle-icon bi bi-chevron-up"></i>'
                    f'</div>'
                    f'<div class="section-content collapse show" id="content-{section_id}">', explanation)
    
    # Close the last section and complete the TOC
    explanation += '</div></section>'
    toc_html += '</ul></div>'
    
    # Subsection Headers
    explanation = re.sub(r'## Option ([A-D]): (.*?)\n', 
                         r'<h3 class="subsection-header option-header"><span class="option-badge option-\1">\1</span> \2</h3>', 
                         explanation)
    explanation = re.sub(r'## (.*?)\n', 
                         r'<h3 class="subsection-header"><i class="bi bi-arrow-right-circle"></i> \1</h3>', 
                         explanation)
    
    # Bold and italic formatting
    explanation = re.sub(r'\*\*(.*?)\*\*', r'<strong>\1</strong>', explanation)
    explanation = re.sub(r'\*(.*?)\*', r'<em>\1</em>', explanation)
    
    # Lists with icons
    explanation = re.sub(r'- (.*?)\n', r'<li class="bullet-item"><i class="bi bi-dash"></i> \1</li>', explanation)
    explanation = re.sub(r'(\d+)\. (.*?)\n', 
                         r'<li class="numbered-item"><span class="number-badge">\1</span> \2</li>', 
                         explanation)
    
    # Improved table handling
    table_pattern = r'\| (.*?) \|[ \t]*\n\|([-|\s]*)\|[ \t]*\n((?:\| .*? \|[ \t]*\n)+)'
    
    def table_replace(match):
        header = match.group(1)
        headers = [h.strip() for h in header.split('|')]
        
        rows_text = match.group(3)
        rows = []
        for row in rows_text.strip().split('\n'):
            row = row.strip('|')
            cells = [cell.strip() for cell in row.split('|')]
            rows.append(cells)
        
        # Create HTML table with Bootstrap styling and card container
        html = '<div class="table-card card shadow-sm mb-4"><div class="table-responsive">'
        html += '<table class="table table-striped table-hover table-bordered mb-0">'
        
        # Table header
        html += '<thead class="table-primary"><tr>'
        for h in headers:
            html += f'<th class="text-center">{h}</th>'
        html += '</tr></thead>'
        
        # Table body with alternating row colors
        html += '<tbody>'
        for i, row in enumerate(rows):
            row_class = 'table-light' if i % 2 == 0 else ''
            html += f'<tr class="{row_class}">'
            for cell in row:
                # Special formatting for the option cells
                if cell.strip() in ['A', 'B', 'C', 'D', 'E']:
                    html += f'<td class="text-center"><span class="option-badge option-{cell.strip()}">{cell}</span></td>'
                elif 'correct' in cell.lower() or 'yes' in cell.lower():
                    html += f'<td class="text-center"><span class="badge bg-success">{cell}</span></td>'
                elif 'incorrect' in cell.lower() or 'no' in cell.lower():
                    html += f'<td class="text-center"><span class="badge bg-danger">{cell}</span></td>'
                else:
                    html += f'<td>{cell}</td>'
            html += '</tr>'
        html += '</tbody></table></div></div>'
        
        return html
    
    explanation = re.sub(table_pattern, table_replace, explanation)
    
    # Fix unordered lists
    explanation = re.sub(r'(<li class="bullet-item">.*?</li>)+', r'<ul class="custom-ul">\g<0></ul>', explanation)
    
    # Fix ordered lists
    explanation = re.sub(r'(<li class="numbered-item">.*?</li>)+', r'<ol class="custom-ol">\g<0></ol>', explanation)
    
    # Special formatting for key sections
    explanation = re.sub(r'Level of evidence:\s*([A-D])', 
                        r'<div class="evidence-level card p-2 mb-3">'
                        r'<div class="evidence-header"><i class="bi bi-award"></i> Evidence Level:</div>'
                        r'<div class="evidence-content"><span class="badge bg-primary evidence-badge">\1</span></div>'
                        r'</div>', 
                        explanation)
    
    explanation = re.sub(r'Key recommendation:\s*(.*?)(?=<)', 
                        r'<div class="key-recommendation card p-2 mb-3">'
                        r'<div class="recommendation-header"><i class="bi bi-star"></i> Key Recommendation:</div>'
                        r'<div class="recommendation-content">\1</div>'
                        r'</div>',
                        explanation)
    
    # References formatting
    explanation = re.sub(r'References?:?\n((?:(?:\d+\.|\-)[^\n]+\n)+)', 
                      r'<div class="references-section p-3 mb-3 mt-3 border-top">'
                      r'<h4 class="references-header mb-2"><i class="bi bi-journal-text"></i> References</h4>'
                      r'<ol class="references-list">\1</ol></div>', 
                      explanation)
    
    # Convert reference list items
    explanation = re.sub(r'(?<=<ol class="references-list">)(\d+\.\s*)(.*?)(?=\n\d+\.|\n<\/ol>)', 
                         r'<li class="reference-item">\2</li>', 
                         explanation)
    
    # Add print button
    print_button = """
    <div class="mb-3 d-flex justify-content-end">
        <button class="btn btn-sm btn-outline-secondary print-explanation" 
            onclick="window.print()">
            <i class="bi bi-printer"></i> Print Explanation
        </button>
    </div>
    """
    
    # Enhanced CSS for explanation with improved formatting and consistency
    css = """
    <style>
    /* Print styles */
    @media print {
        body * {
            visibility: hidden;
        }
        .explanation-wrapper, .explanation-wrapper * {
            visibility: visible;
        }
        .explanation-wrapper {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
        }
        .toggle-icon, .print-explanation, .toc-container {
            display: none !important;
        }
        .section-content {
            display: block !important;
        }
    }
    
    /* Table of Contents */
    .toc-container {
        background-color: #f8f9fa;
        border-radius: 5px;
        padding: 15px;
        border-left: 5px solid #6c757d;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .toc-list {
        list-style-type: none;
        padding-left: 10px;
        margin-bottom: 0;
    }
    .toc-link {
        display: block;
        padding: 8px 0;
        color: #495057;
        text-decoration: none;
        transition: all 0.2s;
        font-weight: 500;
    }
    .toc-link:hover {
        color: #0d6efd;
        transform: translateX(5px);
    }
    
    /* Section styling */
    .explanation-section {
        margin-bottom: 30px;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        background-color: #f8f9fa;
        cursor: pointer;
        transition: all 0.3s;
    }
    .section-header:hover {
        background-color: #e9ecef;
    }
    .section-header h1, .section-header h2 {
        margin: 0;
        font-size: 1.5rem;
        color: #343a40;
        font-weight: 600;
        line-height: 1.4;
    }
    .toggle-icon {
        font-size: 1.2rem;
        transition: transform 0.3s;
    }
    .section-header[aria-expanded="false"] .toggle-icon {
        transform: rotate(180deg);
    }
    .section-content {
        padding: 25px;
        background-color: #ffffff;
        line-height: 1.6;
    }
    
    /* Specific section colors */
    .explanation-section.correct-answer .section-header {
        background-color: rgba(25, 135, 84, 0.1);
        border-left: 5px solid #198754;
    }
    .explanation-section.wrong-answers .section-header {
        background-color: rgba(220, 53, 69, 0.1);
        border-left: 5px solid #dc3545;
    }
    .explanation-section.clinical-pearls .section-header {
        background-color: rgba(255, 193, 7, 0.1);
        border-left: 5px solid #ffc107;
    }
    .explanation-section.guidelines .section-header {
        background-color: rgba(13, 110, 253, 0.1);
        border-left: 5px solid #0d6efd;
    }
    .explanation-section.comparison-table .section-header {
        background-color: rgba(108, 117, 125, 0.1);
        border-left: 5px solid #6c757d;
    }
    .explanation-section.historical-note .section-header {
        background-color: rgba(108, 117, 125, 0.1);
        border-left: 5px solid #6c757d;
    }
    
    /* Subsection headers */
    .subsection-header {
        margin-top: 24px;
        margin-bottom: 16px;
        color: #343a40;
        padding-bottom: 10px;
        border-bottom: 1px solid #dee2e6;
        font-weight: 600;
        line-height: 1.4;
    }
    .option-header {
        display: flex;
        align-items: center;
    }
    
    /* Option badges */
    .option-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        margin-right: 12px;
        font-weight: bold;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .option-A { background-color: #0d6efd; color: white; }
    .option-B { background-color: #198754; color: white; }
    .option-C { background-color: #ffc107; color: black; }
    .option-D { background-color: #dc3545; color: white; }
    .option-E { background-color: #6c757d; color: white; }
    
    /* Number badges */
    .number-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        background-color: #0d6efd;
        color: white;
        margin-right: 12px;
        font-weight: bold;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    /* List styling */
    .custom-ul, .custom-ol {
        padding-left: 0;
        list-style-type: none;
        margin-bottom: 1.5rem;
    }
    .bullet-item, .numbered-item {
        display: flex;
        align-items: flex-start;
        margin-bottom: 12px;
        padding: 8px;
        border-radius: 5px;
        transition: background-color 0.2s;
        line-height: 1.6;
    }
    .bullet-item:hover, .numbered-item:hover {
        background-color: rgba(13, 110, 253, 0.05);
    }
    .bullet-item i, .numbered-item .number-badge {
        margin-top: 2px;
        flex-shrink: 0;
    }
    
    /* Evidence and recommendations */
    .evidence-level, .key-recommendation {
        background-color: #f8f9fa;
        border-radius: 5px;
        padding: 15px;
        margin-bottom: 20px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    .evidence-header, .recommendation-header {
        font-weight: 600;
        margin-bottom: 8px;
        color: #343a40;
    }
    .evidence-badge {
        font-size: 1rem;
        padding: 5px 10px;
    }
    
    /* Table card */
    .table-card {
        border: none;
        overflow: hidden;
        margin: 25px 0;
        box-shadow: 0 2px 5px rgba(0,0,0,0.08);
    }
    .table {
        margin-bottom: 0;
    }
    .table th {
        font-weight: 600;
        vertical-align: middle;
        background-color: #f1f8ff;
        text-align: center;
        padding: 12px;
    }
    .table td {
        vertical-align: middle;
        padding: 10px 12px;
        line-height: 1.5;
    }
    
    /* References section */
    .references-section {
        background-color: #f9f9f9;
        border-radius: 5px;
        border-left: 3px solid #6c757d;
    }
    .references-header {
        color: #343a40;
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: 12px;
    }
    .references-list {
        padding-left: 20px;
        margin-bottom: 0;
    }
    .reference-item {
        margin-bottom: 8px;
        line-height: 1.5;
    }
    
    /* Misc */
    strong {
        color: #343a40;
        font-weight: 600;
    }
    em {
        font-style: italic;
    }
    p {
        margin-bottom: 1rem;
        line-height: 1.6;
    }
    </style>
    """
    
    # Add JavaScript for collapsible sections
    javascript = """
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize collapsible sections
        document.querySelectorAll('.section-header').forEach(function(header) {
            header.addEventListener('click', function() {
                const target = this.getAttribute('data-bs-target');
                const content = document.querySelector(target);
                
                // Toggle the collapse state
                if (content.classList.contains('show')) {
                    content.classList.remove('show');
                    this.setAttribute('aria-expanded', 'false');
                } else {
                    content.classList.add('show');
                    this.setAttribute('aria-expanded', 'true');
                }
            });
        });
        
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(function(link) {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                const targetElement = document.querySelector(targetId);
                
                if (targetElement) {
                    // Scroll to the element
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                    
                    // Ensure the section is expanded
                    const contentId = targetId.replace('section-', 'content-');
                    const contentElement = document.querySelector('#' + contentId);
                    if (contentElement && !contentElement.classList.contains('show')) {
                        contentElement.classList.add('show');
                        const header = targetElement.querySelector('.section-header');
                        if (header) {
                            header.setAttribute('aria-expanded', 'true');
                        }
                    }
                }
            });
        });
    });
    </script>
    """
    
    # Combine everything
    final_explanation = css + print_button + toc_html + explanation_html + explanation + '</div>' + javascript
    
    return final_explanation

# The _process_explanation function has been defined above
    sections = [
        (r'# Explanation of MCQ: (.*?)\n', 'explanation-title', '<i class="bi bi-book"></i> Explanation of MCQ: $1', 'Overview'),
        (r'# Question Recap\n', 'question-recap', '<i class="bi bi-chat-quote"></i> Question Recap', 'Question Recap'),
        (r'# Why the Correct Answer is Right\n', 'correct-answer', '<i class="bi bi-check-circle"></i> Why the Correct Answer is Right', 'Correct Answer'),
        (r'# Why Each Wrong Answer is Wrong\n', 'wrong-answers', '<i class="bi bi-x-circle"></i> Why Each Wrong Answer is Wrong', 'Wrong Answers'),
        (r'# Comparison Table of Options\n', 'comparison-table', '<i class="bi bi-table"></i> Comparison Table of Options', 'Comparison Table'),
        (r'# Clinical Pearls to Memorize\n', 'clinical-pearls', '<i class="bi bi-lightbulb"></i> Clinical Pearls to Memorize', 'Clinical Pearls'),
        (r'# Summary of Latest Guidelines\n', 'guidelines', '<i class="bi bi-journal-medical"></i> Summary of Latest Guidelines', 'Guidelines'),
        (r'# Historical Note\n', 'historical-note', '<i class="bi bi-clock-history"></i> Historical Note', 'Historical Note')
    ]
    
    for i, (pattern, section_id, header_html, toc_label) in enumerate(sections):
        toc_html += f'<li><a href="#section-{section_id}" class="toc-link">{toc_label}</a></li>'
        
        # For the first section (title)
        if i == 0:
            m = re.search(pattern, explanation)
            if m:
                title = m.group(1)
                explanation = re.sub(pattern, 
                    f'<section id="section-{section_id}" class="explanation-section">'
                    f'<div class="section-header" data-bs-toggle="collapse" data-bs-target="#content-{section_id}" aria-expanded="true">'
                    f'<h1>{header_html}</h1>'
                    f'<i class="toggle-icon bi bi-chevron-up"></i>'
                    f'</div>'
                    f'<div class="section-content collapse show" id="content-{section_id}">', explanation)
            else:
                # If no match, add the standard header
                explanation_html += (
                    f'<section id="section-{section_id}" class="explanation-section">'
                    f'<div class="section-header" data-bs-toggle="collapse" data-bs-target="#content-{section_id}" aria-expanded="true">'
                    f'<h1>{header_html.replace("$1", "")}</h1>'
                    f'<i class="toggle-icon bi bi-chevron-up"></i>'
                    f'</div>'
                    f'<div class="section-content collapse show" id="content-{section_id}">'
                )
                
        # For all other sections
        else:
            # Close previous section if needed
            if i > 0:
                explanation = re.sub(pattern, 
                    f'</div></section>'
                    f'<section id="section-{section_id}" class="explanation-section {section_id}">'
                    f'<div class="section-header" data-bs-toggle="collapse" data-bs-target="#content-{section_id}" aria-expanded="true">'
                    f'<h2>{header_html}</h2>'
                    f'<i class="toggle-icon bi bi-chevron-up"></i>'
                    f'</div>'
                    f'<div class="section-content collapse show" id="content-{section_id}">', explanation)
    
    # Close the last section and complete the TOC
    explanation += '</div></section>'
    toc_html += '</ul></div>'
    
    # Subsection Headers
    explanation = re.sub(r'## Option ([A-D]): (.*?)\n', 
                         r'<h3 class="subsection-header option-header"><span class="option-badge option-\1">\1</span> \2</h3>', 
                         explanation)
    explanation = re.sub(r'## (.*?)\n', 
                         r'<h3 class="subsection-header"><i class="bi bi-arrow-right-circle"></i> \1</h3>', 
                         explanation)
    
    # Bold and italic formatting
    explanation = re.sub(r'\*\*(.*?)\*\*', r'<strong>\1</strong>', explanation)
    explanation = re.sub(r'\*(.*?)\*', r'<em>\1</em>', explanation)
    
    # Lists with icons
    explanation = re.sub(r'- (.*?)\n', r'<li class="bullet-item"><i class="bi bi-dash"></i> \1</li>', explanation)
    explanation = re.sub(r'(\d+)\. (.*?)\n', 
                         r'<li class="numbered-item"><span class="number-badge">\1</span> \2</li>', 
                         explanation)
    
    # Improved table handling
    table_pattern = r'\| (.*?) \|[ \t]*\n\|([-|\s]*)\|[ \t]*\n((?:\| .*? \|[ \t]*\n)+)'
    
    def table_replace(match):
        header = match.group(1)
        headers = [h.strip() for h in header.split('|')]
        
        rows_text = match.group(3)
        rows = []
        for row in rows_text.strip().split('\n'):
            row = row.strip('|')
            cells = [cell.strip() for cell in row.split('|')]
            rows.append(cells)
        
        # Create HTML table with Bootstrap styling and card container
        html = '<div class="table-card card shadow-sm mb-4"><div class="table-responsive">'
        html += '<table class="table table-striped table-hover table-bordered mb-0">'
        
        # Table header
        html += '<thead class="table-primary"><tr>'
        for h in headers:
            html += f'<th class="text-center">{h}</th>'
        html += '</tr></thead>'
        
        # Table body with alternating row colors
        html += '<tbody>'
        for i, row in enumerate(rows):
            row_class = 'table-light' if i % 2 == 0 else ''
            html += f'<tr class="{row_class}">'
            for cell in row:
                # Special formatting for the option cells
                if cell.strip() in ['A', 'B', 'C', 'D', 'E']:
                    html += f'<td class="text-center"><span class="option-badge option-{cell.strip()}">{cell}</span></td>'
                elif 'correct' in cell.lower() or 'yes' in cell.lower():
                    html += f'<td class="text-center"><span class="badge bg-success">{cell}</span></td>'
                elif 'incorrect' in cell.lower() or 'no' in cell.lower():
                    html += f'<td class="text-center"><span class="badge bg-danger">{cell}</span></td>'
                else:
                    html += f'<td>{cell}</td>'
            html += '</tr>'
        html += '</tbody></table></div></div>'
        
        return html
    
    explanation = re.sub(table_pattern, table_replace, explanation)
    
    # Fix unordered lists
    explanation = re.sub(r'(<li class="bullet-item">.*?</li>)+', r'<ul class="custom-ul">\g<0></ul>', explanation)
    
    # Fix ordered lists
    explanation = re.sub(r'(<li class="numbered-item">.*?</li>)+', r'<ol class="custom-ol">\g<0></ol>', explanation)
    
    # Special formatting for key sections
    explanation = re.sub(r'Level of evidence:\s*([A-D])', 
                        r'<div class="evidence-level card p-2 mb-3">'
                        r'<div class="evidence-header"><i class="bi bi-award"></i> Evidence Level:</div>'
                        r'<div class="evidence-content"><span class="badge bg-primary evidence-badge">\1</span></div>'
                        r'</div>', 
                        explanation)
    
    explanation = re.sub(r'Key recommendation:\s*(.*?)(?=<)', 
                        r'<div class="key-recommendation card p-2 mb-3">'
                        r'<div class="recommendation-header"><i class="bi bi-star"></i> Key Recommendation:</div>'
                        r'<div class="recommendation-content">\1</div>'
                        r'</div>',
                        explanation)
    
    # References formatting
    explanation = re.sub(r'References?:?\n((?:(?:\d+\.|\-)[^\n]+\n)+)', 
                      r'<div class="references-section p-3 mb-3 mt-3 border-top">'
                      r'<h4 class="references-header mb-2"><i class="bi bi-journal-text"></i> References</h4>'
                      r'<ol class="references-list">\1</ol></div>', 
                      explanation)
    
    # Convert reference list items
    explanation = re.sub(r'(?<=<ol class="references-list">)(\d+\.\s*)(.*?)(?=\n\d+\.|\n<\/ol>)', 
                         r'<li class="reference-item">\2</li>', 
                         explanation)
    
    # Add print button
    print_button = """
    <div class="mb-3 d-flex justify-content-end">
        <button class="btn btn-sm btn-outline-secondary print-explanation" 
            onclick="window.print()">
            <i class="bi bi-printer"></i> Print Explanation
        </button>
    </div>
    """
    
    # Enhanced CSS for explanation with improved formatting and consistency
    css = """
    <style>
    /* Print styles */
    @media print {
        body * {
            visibility: hidden;
        }
        .explanation-wrapper, .explanation-wrapper * {
            visibility: visible;
        }
        .explanation-wrapper {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
        }
        .toggle-icon, .print-explanation, .toc-container {
            display: none !important;
        }
        .section-content {
            display: block !important;
        }
    }
    
    /* Table of Contents */
    .toc-container {
        background-color: #f8f9fa;
        border-radius: 5px;
        padding: 15px;
        border-left: 5px solid #6c757d;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .toc-list {
        list-style-type: none;
        padding-left: 10px;
        margin-bottom: 0;
    }
    .toc-link {
        display: block;
        padding: 8px 0;
        color: #495057;
        text-decoration: none;
        transition: all 0.2s;
        font-weight: 500;
    }
    .toc-link:hover {
        color: #0d6efd;
        transform: translateX(5px);
    }
    
    /* Section styling */
    .explanation-section {
        margin-bottom: 30px;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        background-color: #f8f9fa;
        cursor: pointer;
        transition: all 0.3s;
    }
    .section-header:hover {
        background-color: #e9ecef;
    }
    .section-header h1, .section-header h2 {
        margin: 0;
        font-size: 1.5rem;
        color: #343a40;
        font-weight: 600;
        line-height: 1.4;
    }
    .toggle-icon {
        font-size: 1.2rem;
        transition: transform 0.3s;
    }
    .section-header[aria-expanded="false"] .toggle-icon {
        transform: rotate(180deg);
    }
    .section-content {
        padding: 25px;
        background-color: #ffffff;
        line-height: 1.6;
    }
    
    /* Specific section colors */
    .explanation-section.correct-answer .section-header {
        background-color: rgba(25, 135, 84, 0.1);
        border-left: 5px solid #198754;
    }
    .explanation-section.wrong-answers .section-header {
        background-color: rgba(220, 53, 69, 0.1);
        border-left: 5px solid #dc3545;
    }
    .explanation-section.clinical-pearls .section-header {
        background-color: rgba(255, 193, 7, 0.1);
        border-left: 5px solid #ffc107;
    }
    .explanation-section.guidelines .section-header {
        background-color: rgba(13, 110, 253, 0.1);
        border-left: 5px solid #0d6efd;
    }
    .explanation-section.comparison-table .section-header {
        background-color: rgba(108, 117, 125, 0.1);
        border-left: 5px solid #6c757d;
    }
    .explanation-section.historical-note .section-header {
        background-color: rgba(108, 117, 125, 0.1);
        border-left: 5px solid #6c757d;
    }
    
    /* Subsection headers */
    .subsection-header {
        margin-top: 24px;
        margin-bottom: 16px;
        color: #343a40;
        padding-bottom: 10px;
        border-bottom: 1px solid #dee2e6;
        font-weight: 600;
        line-height: 1.4;
    }
    .option-header {
        display: flex;
        align-items: center;
    }
    
    /* Option badges */
    .option-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        margin-right: 12px;
        font-weight: bold;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .option-A { background-color: #0d6efd; color: white; }
    .option-B { background-color: #198754; color: white; }
    .option-C { background-color: #ffc107; color: black; }
    .option-D { background-color: #dc3545; color: white; }
    .option-E { background-color: #6c757d; color: white; }
    
    /* Number badges */
    .number-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        background-color: #0d6efd;
        color: white;
        margin-right: 12px;
        font-weight: bold;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    /* List styling */
    .custom-ul, .custom-ol {
        padding-left: 0;
        list-style-type: none;
        margin-bottom: 1.5rem;
    }
    .bullet-item, .numbered-item {
        display: flex;
        align-items: flex-start;
        margin-bottom: 12px;
        padding: 8px;
        border-radius: 5px;
        transition: background-color 0.2s;
        line-height: 1.6;
    }
    .bullet-item:hover, .numbered-item:hover {
        background-color: rgba(13, 110, 253, 0.05);
    }
    .bullet-item i, .numbered-item .number-badge {
        margin-top: 2px;
        flex-shrink: 0;
    }
    
    /* Evidence and recommendations */
    .evidence-level, .key-recommendation {
        background-color: #f8f9fa;
        border-radius: 5px;
        padding: 15px;
        margin-bottom: 20px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    .evidence-header, .recommendation-header {
        font-weight: 600;
        margin-bottom: 8px;
        color: #343a40;
    }
    .evidence-badge {
        font-size: 1rem;
        padding: 5px 10px;
    }
    
    /* Table card */
    .table-card {
        border: none;
        overflow: hidden;
        margin: 25px 0;
        box-shadow: 0 2px 5px rgba(0,0,0,0.08);
    }
    .table {
        margin-bottom: 0;
    }
    .table th {
        font-weight: 600;
        vertical-align: middle;
        background-color: #f1f8ff;
        text-align: center;
        padding: 12px;
    }
    .table td {
        vertical-align: middle;
        padding: 10px 12px;
        line-height: 1.5;
    }
    
    /* References section */
    .references-section {
        background-color: #f9f9f9;
        border-radius: 5px;
        border-left: 3px solid #6c757d;
    }
    .references-header {
        color: #343a40;
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: 12px;
    }
    .references-list {
        padding-left: 20px;
        margin-bottom: 0;
    }
    .reference-item {
        margin-bottom: 8px;
        line-height: 1.5;
    }
    
    /* Misc */
    strong {
        color: #343a40;
        font-weight: 600;
    }
    em {
        font-style: italic;
    }
    p {
        margin-bottom: 1rem;
        line-height: 1.6;
    }
    </style>
    """
    
    # Add JavaScript for collapsible sections
    javascript = """
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize collapsible sections
        document.querySelectorAll('.section-header').forEach(function(header) {
            header.addEventListener('click', function() {
                const target = this.getAttribute('data-bs-target');
                const content = document.querySelector(target);
                
                // Toggle the collapse state
                if (content.classList.contains('show')) {
                    content.classList.remove('show');
                    this.setAttribute('aria-expanded', 'false');
                } else {
                    content.classList.add('show');
                    this.setAttribute('aria-expanded', 'true');
                }
            });
        });
        
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(function(link) {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                const targetElement = document.querySelector(targetId);
                
                if (targetElement) {
                    // Scroll to the element
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                    
                    // Ensure the section is expanded
                    const contentId = targetId.replace('section-', 'content-');
                    const contentElement = document.querySelector('#' + contentId);
                    if (contentElement && !contentElement.classList.contains('show')) {
                        contentElement.classList.add('show');
                        const header = targetElement.querySelector('.section-header');
                        if (header) {
                            header.setAttribute('aria-expanded', 'true');
                        }
                    }
                }
            });
        });
    });
    </script>
    """
    
    # Combine everything
    final_explanation = css + print_button + toc_html + explanation_html + explanation + '</div>' + javascript
    
    # Update the database with the new explanation
    mcq.explanation = final_explanation
    mcq.save()
    
    # Return JSON response instead of redirecting to prevent browser navigation issues
    return JsonResponse({
        'success': True,
        'message': f"Explanation created successfully for MCQ #{mcq_id}"
    })

@login_required
@require_POST
def improve_mcq_view(request, mcq_id):
    mcq = get_object_or_404(MCQ, id=mcq_id)
    
    # Store original question for comparison
    original_question = mcq.question_text
    
    # Generate improved question (only rephrased for clarity) using OpenAI
    improved_question = improve_question(mcq)
    
    # Check if the question actually changed
    if improved_question == original_question:
        messages.info(request, f"No changes were made to MCQ #{mcq_id}. The question already has optimal phrasing.")
        return redirect('view_mcq', mcq_id=mcq_id)
    
    # Update the database with the improved question
    mcq.question_text = improved_question
    mcq.save()
    
    messages.success(request, f"MCQ #{mcq_id} rephrased for clarity. No medical content was altered.")
    return redirect('view_mcq', mcq_id=mcq_id)

@login_required
@require_POST
def new_options_view(request, mcq_id):
    mcq = get_object_or_404(MCQ, id=mcq_id)
    
    # Generate new options using OpenAI
    new_options_result = generate_new_options(mcq)
    
    # Check if we got a valid result (not an error)
    if isinstance(new_options_result, dict) and not 'error' in new_options_result:
        # Update the database with the new options
        mcq.options = new_options_result
        mcq.save()
        messages.success(request, f"New options generated for MCQ #{mcq_id}")
    else:
        # Handle error
        error_msg = new_options_result.get('error', 'Unknown error generating options')
        messages.error(request, f"Error: {error_msg}")
    
    return redirect('view_mcq', mcq_id=mcq_id)

@login_required
def verify_answer(request, mcq_id):
    if request.method != 'POST':
        return JsonResponse({'error': 'Only POST requests allowed'})
    
    mcq = get_object_or_404(MCQ, id=mcq_id)
    
    # Verify the answer using OpenAI
    analysis = verify_mcq_answer(mcq)
    
    return JsonResponse({
        'analysis': analysis
    })

@login_required
def ask_gpt(request, mcq_id):
    if request.method != 'POST':
        return JsonResponse({'error': 'Only POST requests allowed'})
    
    question = request.POST.get('question', '')
    
    if not question:
        return JsonResponse({'error': 'Question is required'})
    
    mcq = get_object_or_404(MCQ, id=mcq_id)
    
    # Get answer from OpenAI
    answer = answer_question_about_mcq(mcq, question)
    
    return JsonResponse({
        'answer': answer
    })

@login_required
def diagnostics_view(request):
    # Check database status
    mcq_count = MCQ.objects.count()
    
    # Get subspecialties
    subspecialties = MCQ.objects.values('subspecialty').annotate(
        count=Count('id')).order_by('subspecialty')
    
    # Get first 5 MCQs
    sample_mcqs = MCQ.objects.all().order_by('id')[:5]
    
    context = {
        'mcq_count': mcq_count,
        'subspecialties': subspecialties,
        'sample_mcqs': sample_mcqs,
    }
    
    return render(request, 'mcq/diagnostics.html', context)

# Import form route
@login_required
def import_mcqs_form(request):
    if request.method == 'POST':
        # Handle JSON file import
        if request.FILES.get('json_file'):
            json_file = request.FILES['json_file']
            
            try:
                mcqs_data = json.loads(json_file.read().decode('utf-8'))
                
                total_count = len(mcqs_data)
                imported_count = 0
                existing_count = 0
                
                for mcq_data in mcqs_data:
                    # Check if MCQ already exists
                    if MCQ.objects.filter(
                        question_number=mcq_data.get('question_number'),
                        question_text=mcq_data.get('question_text')
                    ).exists():
                        existing_count += 1
                        continue
                    
                    # Create the MCQ
                    MCQ.objects.create(
                        question_number=mcq_data.get('question_number'),
                        question_text=mcq_data.get('question_text', 'Missing question text'),
                        options=mcq_data.get('options'),
                        correct_answer=mcq_data.get('correct_answer', 'A'),
                        subspecialty=mcq_data.get('subspecialty', 'Other/Unclassified'),
                        source_file=mcq_data.get('source_file'),
                        exam_type=mcq_data.get('exam_type'),
                        exam_year=mcq_data.get('exam_year'),
                        explanation=mcq_data.get('explanation')
                    )
                    imported_count += 1
                
                messages.success(request, f'Successfully imported {imported_count} MCQs. {existing_count} were already in the database.')
                return redirect('dashboard')
                
            except Exception as e:
                messages.error(request, f'Error importing MCQs from JSON: {str(e)}')
        
        # Handle text format import
        elif request.POST.get('mcqs_text'):
            mcqs_text = request.POST.get('mcqs_text')
            
            try:
                # Split by the separator
                mcq_blocks = mcqs_text.split('--------------------------------------------------')
                
                total_count = len(mcq_blocks)
                imported_count = 0
                existing_count = 0
                
                for mcq_block in mcq_blocks:
                    if not mcq_block.strip():
                        continue
                    
                    # Parse the MCQ block
                    lines = mcq_block.strip().split('\n')
                    
                    # Extract question number and source - handle different formats
                    question_match = re.search(r'Q(\d+)\.?\s*(?:\(Source:\s*(.*?)\))?', lines[0])
                    if not question_match:
                        # Try alternative formats
                        alt_match = re.search(r'Q\.?\s*(\d+)|Question\s*(\d+)', lines[0], re.IGNORECASE)
                        if alt_match:
                            question_num = alt_match.group(1) or alt_match.group(2)
                            question_number = f"Q{question_num}"
                            # Look for source in the first few lines
                            source_file = ""
                            for i in range(min(3, len(lines))):
                                source_search = re.search(r'Source:\s*(.*?)(?:\s|$)', lines[i], re.IGNORECASE)
                                if source_search:
                                    source_file = source_search.group(1).strip()
                                    break
                        else:
                            # If we still can't find a question number, skip this block
                            continue
                    else:
                        question_number = f"Q{question_match.group(1)}"
                        source_file = question_match.group(2).strip() if question_match.group(2) else ""
                    
                    # Extract exam type and year from source
                    exam_type = None
                    exam_year = None
                    
                    # More comprehensive pattern matching for exam type
                    if re.search(r'Part\s*I\b|Part\s*1\b', source_file, re.IGNORECASE):
                        exam_type = "Part I"
                    elif re.search(r'Part\s*II\b|Part\s*2\b|part\s*2\b|part\s*II\b', source_file, re.IGNORECASE):
                        exam_type = "Part II"
                    elif re.search(r'Promotion', source_file, re.IGNORECASE):
                        exam_type = "Promotion"
                    elif re.search(r'ABPN', source_file, re.IGNORECASE):
                        exam_type = "ABPN Board"
                    
                    # Extract year with improved pattern
                    year_match = re.search(r'20\d{2}', source_file)
                    if year_match:
                        exam_year = int(year_match.group(0))
                    
                    # Extract question text with improved handling for different formats
                    question_text = ""
                    line_index = 1
                    
                    # Skip any empty lines at the beginning
                    while line_index < len(lines) and not lines[line_index].strip():
                        line_index += 1
                    
                    # Read until we hit something that looks like an option (A., A:, etc.)
                    while line_index < len(lines):
                        line = lines[line_index].strip()
                        # Stop if we hit an option line
                        if re.match(r'^[A-E][\.\)\-:\s]', line):
                            break
                        # Add non-empty lines to question text
                        if line:
                            question_text += line + " "
                        line_index += 1
                    
                    question_text = question_text.strip()
                    
                    # Extract options and correct answer with improved handling
                    options = {}
                    correct_answer = None
                    
                    while line_index < len(lines) and lines[line_index].strip() and not lines[line_index].strip().startswith('*'):
                        line = lines[line_index].strip()
                        
                        # Match various option formats: A., A), A-, etc.
                        option_match = re.match(r'^([A-E])[\.\)\-:\s]\s*(.*)', line)
                        
                        if option_match:
                            option_letter = option_match.group(1)
                            option_text = option_match.group(2).strip()
                            
                            # Check for [CORRECT] marker in different formats
                            if re.search(r'\[CORRECT\]|\(CORRECT\)|CORRECT', option_text, re.IGNORECASE):
                                correct_answer = option_letter
                                # Remove any correct markers with different bracket types
                                option_text = re.sub(r'\s*[\[\(]CORRECT[\]\)]|\s*CORRECT', '', option_text, flags=re.IGNORECASE).strip()
                            
                            options[option_letter] = option_text
                        elif line and line_index > 0 and options:
                            # This might be a continuation of the previous option
                            last_option = list(options.keys())[-1]
                            options[last_option] += " " + line
                        
                        line_index += 1
                    
                    # If no correct answer was found but there's a CORRECT ANSWER: line, check for that
                    if not correct_answer:
                        for line in lines:
                            correct_match = re.search(r'CORRECT\s+ANSWER\s*:\s*([A-E])', line, re.IGNORECASE)
                            if correct_match:
                                correct_answer = correct_match.group(1)
                                break
                    
                    # Extract explanation/classification with improved detection
                    explanation = ""
                    for line in lines:
                        # Match different formats of classification reason
                        if re.match(r'^\s*\*+\s*(Classification\s*Reason:|Explanation:)', line, re.IGNORECASE):
                            explanation = line.strip()
                            break
                    
                    # If no explanation found, look for any line starting with * that might be a comment
                    if not explanation:
                        for line in lines:
                            if line.strip().startswith('*') and len(line.strip()) > 2:
                                explanation = line.strip()
                                break
                    
                    # Determine subspecialty from classification reason
                    subspecialty = "Other/Unclassified"
                    
                    # Map of keywords to subspecialties
                    subspecialty_keywords = {
                        "dementia": "Dementia",
                        "alzheimer": "Dementia",
                        "frontotemporal": "Dementia",
                        "memory": "Dementia",
                        "epilepsy": "Epilepsy",
                        "seizure": "Epilepsy",
                        "vascular": "Vascular neurology stroke",
                        "stroke": "Vascular neurology stroke",
                        "headache": "Headache",
                        "migraine": "Headache",
                        "movement": "Movement Disorders",
                        "parkinson": "Movement Disorders",
                        "tremor": "Movement Disorders",
                        "dystonia": "Movement Disorders",
                        "muscle": "Neuromuscular",
                        "neuropathy": "Neuromuscular",
                        "myopathy": "Neuromuscular",
                        "infection": "Neuro infectious",
                        "meningitis": "Neuro infectious",
                        "encephalitis": "Neuro infectious",
                        "tumor": "Neuro oncology",
                        "cancer": "Neuro oncology",
                        "glioma": "Neuro oncology",
                        "mass": "Neuro oncology",
                        "multiple sclerosis": "Neuroimmunology",
                        "autoimmune": "Neuroimmunology",
                        "immune": "Neuroimmunology",
                        "sleep": "Sleep Neurology",
                        "narcolepsy": "Sleep Neurology",
                        "eye": "Neuroophthalmology",
                        "vision": "Neuroophthalmology",
                        "child": "Pediatric Neurology",
                        "pediatric": "Pediatric Neurology",
                        "toxin": "Neurotoxicology",
                        "toxic": "Neurotoxicology",
                        "psychiatric": "Neuropsychiatry",
                        "behavior": "Neuropsychiatry",
                        "anatomy": "Neuroanatomy",
                        "tract": "Neuroanatomy",
                        "critical": "Critical Care Neurology",
                        "emergency": "Critical Care Neurology",
                        "coma": "Critical Care Neurology",
                        "genetic": "Neurogenetics"
                    }
                    
                    # Check classification reason for keywords
                    if explanation:
                        # Get the lowercase version for case-insensitive matching
                        explanation_lower = explanation.lower()
                        
                        # Try to find matching keywords in the explanation
                        for keyword, related_subspecialty in subspecialty_keywords.items():
                            if keyword in explanation_lower:
                                subspecialty = related_subspecialty
                                break
                                
                        # Also try to extract from source file name if it has subspecialty indicators
                        if "Dementia" in source_file:
                            subspecialty = "Dementia"
                        elif "Stroke" in source_file or "Vascular" in source_file:
                            subspecialty = "Vascular neurology stroke"
                        # Add more source file pattern matching as needed
                    
                    # Check if the MCQ already exists
                    if MCQ.objects.filter(question_number=question_number, question_text=question_text).exists():
                        existing_count += 1
                        continue
                    
                    # Convert options to JSON
                    options_json = json.dumps(options)
                    
                    # Create the MCQ without the classification reason
                    # Don't store the Classification Reason as per user request
                    MCQ.objects.create(
                        question_number=question_number,
                        question_text=question_text,
                        options=options_json,
                        correct_answer=correct_answer or "A",
                        subspecialty=subspecialty,
                        source_file=source_file,
                        exam_type=exam_type,
                        exam_year=exam_year,
                        explanation="" # No classification reason saved
                    )
                    imported_count += 1
                
                messages.success(request, f'Successfully imported {imported_count} MCQs. {existing_count} were already in the database.')
                return redirect('dashboard')
                
            except Exception as e:
                messages.error(request, f'Error importing MCQs from text: {str(e)}')
        
        else:
            messages.error(request, 'Please provide either a JSON file or MCQ text to import.')
    
    return render(request, 'mcq/import_form.html', {'subspecialties': SUBSPECIALTIES})

# ReasoningPal routes
@login_required
@csrf_exempt
def reasoning_pal(request, mcq_id):
    """View to handle ReasoningPal interactions"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    # Get the user's answer and reasoning
    selected_answer = request.POST.get('selected_answer')
    user_reasoning = request.POST.get('user_reasoning')
    is_correct = request.POST.get('is_correct') == 'true'
    
    if not selected_answer or not user_reasoning:
        return JsonResponse({'error': 'Missing required information'}, status=400)
    
    # Get the MCQ from the database
    mcq = get_object_or_404(MCQ, id=mcq_id)
    
    # Generate clinical reasoning guidance
    guidance = clinical_reasoning_coach(mcq, selected_answer, user_reasoning, is_correct)
    
    # Track the reasoning session
    session = ReasoningSession.objects.create(
        user=request.user,
        mcq=mcq,
        selected_answer=selected_answer,
        is_correct=is_correct,
        user_reasoning=user_reasoning
    )
    
    return JsonResponse({
        'guidance': guidance,
        'session_id': session.id
    })

@login_required
@csrf_exempt
def reasoning_feedback(request, session_id):
    """View to handle feedback on ReasoningPal sessions"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    # Get the session
    session = get_object_or_404(ReasoningSession, id=session_id, user=request.user)
    
    # Get feedback data
    satisfaction_level = request.POST.get('satisfaction_level')
    follow_up_question = request.POST.get('follow_up_question', '')
    
    # Update the session
    session.satisfaction_level = satisfaction_level
    session.save()
    
    # Handle follow-up question if provided
    follow_up_answer = None
    if follow_up_question:
        # Use the MCQ from the session to answer the follow-up
        mcq = session.mcq
        follow_up_answer = answer_question_about_mcq(mcq, follow_up_question)
    
    return JsonResponse({
        'status': 'feedback recorded',
        'follow_up_answer': follow_up_answer
    })